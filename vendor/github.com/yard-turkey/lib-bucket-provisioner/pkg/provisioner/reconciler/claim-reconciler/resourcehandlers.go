package reconciler

import (
	"context"
	"fmt"
	"strconv"
	"time"

	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/util/wait"

	"sigs.k8s.io/controller-runtime/pkg/client"

	"github.com/yard-turkey/lib-bucket-provisioner/pkg/apis/objectbucket.io/v1alpha1"
	"github.com/yard-turkey/lib-bucket-provisioner/pkg/provisioner/api"
)

const (
	// defaultRetryBaseInterval controls how long to wait for a single create API object call
	defaultRetryBaseInterval = time.Second * 3
	// defaultRetryTimeout defines how long in total to try to create an API object before ending the reconciliation
	// attempt
	defaultRetryTimeout = time.Second * 30

	bucketName      = "BUCKET_NAME"
	bucketHost      = "BUCKET_HOST"
	bucketPort      = "BUCKET_PORT"
	bucketRegion    = "BUCKET_REGION"
	bucketSubRegion = "BUCKET_SUBREGION"
	bucketSSL       = "BUCKET_SSL"

	// finalizer is applied to all resources generated by the provisioner
	finalizer = api.Domain + "/finalizer"

	objectBucketNameFormat = "obc-%s-%s"
)

// createUntilDefaultTimeout allows the controller to mitigate infrequent client.Create() errors by retrying the
// call several times in quick succession.  Each call is given defaultRetryBaseInterval seconds to complete until
// defaultRetryTimeout is reached.  At this point, a timeout error is returned and the reconcile attempt is ended.
func createUntilDefaultTimeout(obj runtime.Object, c client.Client, interval, timeout time.Duration) error {
	logD.Info("creating object until timeout", "interval", interval, "timeout", timeout)
	if c == nil {
		return fmt.Errorf("error creating object, nil client")
	}
	if obj == nil {
		return fmt.Errorf("passed in object is nil")
	}

	return wait.PollImmediate(interval, timeout, func() (done bool, err error) {
		err = c.Create(context.Background(), obj)
		if err != nil {
			if errors.IsAlreadyExists(err) {
				// The object already exists don't spam the logs, instead let the request be requeued
				return true, err
			}
			// The error could be intermittent, log and try again
			log.Error(err, "probably not fatal, retrying")
			return false, nil
		}
		return true, nil
	})
}

// newBucketConfigMap constructs a config map from a given endpoint and ObjectBucketClaim As a quality of life addition,
// it constructs a full URL for the bucket path. Success is constrained by a defined Bucket name and Bucket host.
func newBucketConfigMap(ep *v1alpha1.Endpoint, obc *v1alpha1.ObjectBucketClaim) (*corev1.ConfigMap, error) {
	logD.Info("defining new configMap", "for claim", obc.Namespace+"/"+obc.Name)
	if ep == nil {
		return nil, fmt.Errorf("cannot construct configMap, got nil Endpoint")
	}
	if obc == nil {
		return nil, fmt.Errorf("cannot construct configMap, got nil OBC")
	}

	return &corev1.ConfigMap{
		ObjectMeta: metav1.ObjectMeta{
			Name:       obc.Name,
			Namespace:  obc.Namespace,
			Finalizers: []string{finalizer},
		},
		Data: map[string]string{
			bucketName:      ep.BucketName,
			bucketHost:      ep.BucketHost,
			bucketPort:      strconv.Itoa(ep.BucketPort),
			bucketSSL:       strconv.FormatBool(ep.SSL),
			bucketRegion:    ep.Region,
			bucketSubRegion: ep.SubRegion,
		},
	}, nil
}

// NewCredentialsSecret returns a secret with data appropriate to the supported authenticaion method. Even if the values
// for the Authentication keys are empty, we generate the secret.
func newCredentialsSecret(obc *v1alpha1.ObjectBucketClaim, auth *v1alpha1.Authentication) (*corev1.Secret, error) {

	if obc == nil {
		return nil, fmt.Errorf("ObjectBucketClaim required to generate secret")
	}
	if auth == nil {
		return nil, fmt.Errorf("got nil authentication, nothing to do")
	}

	secret := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:       obc.Name,
			Namespace:  obc.Namespace,
			Finalizers: []string{finalizer},
		},
	}

	secret.StringData = auth.ToMap()
	return secret, nil
}

func createObjectBucket(ob *v1alpha1.ObjectBucket, c client.Client, retryInterval, retryTimeout time.Duration) (*v1alpha1.ObjectBucket, error) {
	logD.Info("creating ObjectBucket", "name", ob.Name)
	if err := createUntilDefaultTimeout(ob, c, retryInterval, retryTimeout); err != nil {
		return nil, err
	}
	return ob, nil
}

func createSecret(obc *v1alpha1.ObjectBucketClaim, auth *v1alpha1.Authentication, c client.Client, retryInterval, retryTimeout time.Duration) (*corev1.Secret, error) {
	secret, err := newCredentialsSecret(obc, auth)
	if err != nil {
		return nil, err
	}

	logD.Info("creating Secret", "namespace", secret.Namespace, "name", secret.Name)
	if err = createUntilDefaultTimeout(secret, c, retryInterval, retryTimeout); err != nil {
		return nil, fmt.Errorf("unable to create Secret %q: %v", secret.Name, err)
	}
	return secret, nil
}

func createConfigMap(obc *v1alpha1.ObjectBucketClaim, ep *v1alpha1.Endpoint, c client.Client, retryInterval, retryTimeout time.Duration) (*corev1.ConfigMap, error) {
	configMap, err := newBucketConfigMap(ep, obc)
	if err != nil {
		return nil, nil
	}

	logD.Info("creating configMap", "namespace", configMap.Namespace, "name", configMap.Name)
	err = createUntilDefaultTimeout(configMap, c, retryInterval, retryTimeout)
	if err != nil {
		return nil, fmt.Errorf("unable to create configMap %q for claim %v: %v", configMap.Name, configMap.Name, err)
	}
	return configMap, nil
}

func deleteConfigMap(cm *corev1.ConfigMap, ic *internalClient) error {
	if cm == nil {
		log.Info("got nil configMap pointer, skipping delete")
		return nil
	}
	if hasFinalizer(cm) {
		logD.Info("removing finalizer from configMap", "name", cm.Name)

		err := removeFinalizer(cm, ic)
		if err != nil {
			if errors.IsNotFound(err) {
				log.Error(err, "configMap vanished before we could remove the finalizer, assuming deleted")
				return nil
			}
			return fmt.Errorf("error removing finalizer on configMap %s/%s: %v", cm.Namespace, cm.Name, err)
		}
	}

	logD.Info("deleting configMap", "name", cm.Namespace+"/"+cm.Name)
	err := ic.Delete(context.Background(), cm)
	if err != nil {
		if errors.IsNotFound(err) {
			log.Error(err, "configMap vanished before we could delete it, skipping")
			return nil
		}
		return fmt.Errorf("error deleting configMap %s/%s: %v", cm.Namespace, cm.Name, err)
	}
	return nil
}

func deleteSecret(sec *corev1.Secret, ic *internalClient) error {
	if sec == nil {
		log.Info("got nil secret, skipping")
		return nil
	}
	if hasFinalizer(sec) {
		logD.Info("removing finalizer from Secret", "name", sec.Namespace+"/"+sec.Name)

		err := removeFinalizer(sec, ic)
		if err != nil {
			if errors.IsNotFound(err) {
				log.Error(err, "secret vanished before we could remove the finalizer, assuming deleted")
				return nil
			}
			return fmt.Errorf("error removing finalizer on Secret %s/%s: %v", sec.Namespace, sec.Name, err)
		}
	}

	logD.Info("deleting secret", "name", sec.Namespace+"/"+sec.Name)
	err := ic.Delete(context.Background(), sec)
	if err != nil {
		if errors.IsNotFound(err) {
			log.Error(err, "secret vanished before we could delete it, skipping")
			return nil
		}
		return fmt.Errorf("error deleting Secret %s/%s: %v", sec.Namespace, sec.Name, err)
	}
	return nil
}

func deleteObjectBucket(ob *v1alpha1.ObjectBucket, ic *internalClient) error {
	if ob == nil {
		log.Error(fmt.Errorf("got nil objectBucket, skipping"), "")
		return nil
	}
	logD.Info("deleting ObjectBucket", "name", ob.Name)
	if hasFinalizer(ob) {
		err := removeFinalizer(ob, ic)
		if err != nil {
			if errors.IsNotFound(err) {
				log.Info("ObjectBucket %v vanished before we could remove the finalizer, assuming deleted")
				return nil
			}
			return fmt.Errorf("error removing finalizer on ObjectBucket %s: %v", ob.Name, err)
		}
	}

	err := ic.Delete(context.Background(), ob)
	if err != nil {
		if errors.IsNotFound(err) {
			log.Error(err, "ObjectBucket vanished before we could delete it, skipping")
			return nil
		}
		return fmt.Errorf("error deleting ObjectBucket %s/%s: %v", ob.Namespace, ob.Name, err)
	}
	return nil
}

func updateClaim(ic *internalClient, obc *v1alpha1.ObjectBucketClaim, retryInterval, retryTimeout time.Duration) error {
	err := wait.PollImmediate(retryInterval, retryTimeout, func() (done bool, err error) {
		// err is a shadow var
		err = ic.Status().Update(ic.ctx, obc)
		if err == nil {
			return true, nil
		}
		if errors.IsNotFound(err) {
			return true, err
		}
		log.Error(err, "possibly intermittent, retrying")
		return false, nil
	})
	return err
}

func updateObjectBucketClaimPhase(ic *internalClient, obc *v1alpha1.ObjectBucketClaim, phase v1alpha1.ObjectBucketClaimStatusPhase, retryInterval, retryTimeout time.Duration) (*v1alpha1.ObjectBucketClaim, error) {
	obc.Status.Phase = phase
	err := updateStatus(ic, obc, retryInterval, retryTimeout)
	if err != nil {
		return nil, fmt.Errorf("error updating phase: %v", err)
	}
	return obc, nil
}

func updateObjectBucketPhase(ic *internalClient, ob *v1alpha1.ObjectBucket, phase v1alpha1.ObjectBucketStatusPhase, retryInterval, retryTimeout time.Duration) (*v1alpha1.ObjectBucket, error) {
	ob.Status.Phase = phase
	err := updateStatus(ic, ob, retryInterval, retryTimeout)
	if err != nil {
		return nil, fmt.Errorf("error updating phase: %v", err)
	}
	return ob, nil
}

func updateStatus(ic *internalClient, o runtime.Object, i, t time.Duration) error {
	return wait.PollImmediate(i, t, func() (done bool, err error) {
		err = ic.Status().Update(ic.ctx, o)
		if err == nil {
			return true, nil
		}
		if errors.IsNotFound(err) {
			return true, err
		}
		log.Error(err, "possibly intermittent, retrying")
		return false, nil
	})
}
