package provisioner

import (
	"fmt"
	"strconv"
	"time"

	"k8s.io/client-go/kubernetes"

	"github.com/yard-turkey/lib-bucket-provisioner/pkg/client/clientset/versioned"

	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/wait"

	"github.com/yard-turkey/lib-bucket-provisioner/pkg/apis/objectbucket.io/v1alpha1"
	"github.com/yard-turkey/lib-bucket-provisioner/pkg/provisioner/api"
)

const (
	// defaultRetryBaseInterval controls how long to wait for a single create API object call
	defaultRetryBaseInterval = time.Second * 3
	// defaultRetryTimeout defines how long in total to try to create an API object before ending the reconciliation
	// attempt
	defaultRetryTimeout = time.Second * 30

	bucketName      = "BUCKET_NAME"
	bucketHost      = "BUCKET_HOST"
	bucketPort      = "BUCKET_PORT"
	bucketRegion    = "BUCKET_REGION"
	bucketSubRegion = "BUCKET_SUBREGION"
	bucketSSL       = "BUCKET_SSL"

	// finalizer is applied to all resources generated by the provisioner
	finalizer = api.Domain + "/finalizer"

	objectBucketNameFormat = "obc-%s-%s"
)

// newBucketConfigMap constructs a config map from a given endpoint and ObjectBucketClaim As a quality of life addition,
// it constructs a full URL for the bucket path. Success is constrained by a defined Bucket name and Bucket host.
func newBucketConfigMap(ep *v1alpha1.Endpoint, obc *v1alpha1.ObjectBucketClaim) (*corev1.ConfigMap, error) {
	logD.Info("defining new configMap", "for claim", obc.Namespace+"/"+obc.Name)
	if ep == nil {
		return nil, fmt.Errorf("cannot construct configMap, got nil Endpoint")
	}
	if obc == nil {
		return nil, fmt.Errorf("cannot construct configMap, got nil OBC")
	}

	return &corev1.ConfigMap{
		ObjectMeta: metav1.ObjectMeta{
			Name:       obc.Name,
			Namespace:  obc.Namespace,
			Finalizers: []string{finalizer},
		},
		Data: map[string]string{
			bucketName:      ep.BucketName,
			bucketHost:      ep.BucketHost,
			bucketPort:      strconv.Itoa(ep.BucketPort),
			bucketSSL:       strconv.FormatBool(ep.SSL),
			bucketRegion:    ep.Region,
			bucketSubRegion: ep.SubRegion,
		},
	}, nil
}

// NewCredentialsSecret returns a secret with data appropriate to the supported authenticaion method. Even if the values
// for the Authentication keys are empty, we generate the secret.
func newCredentialsSecret(obc *v1alpha1.ObjectBucketClaim, auth *v1alpha1.Authentication) (*corev1.Secret, error) {

	if obc == nil {
		return nil, fmt.Errorf("ObjectBucketClaim required to generate secret")
	}
	if auth == nil {
		return nil, fmt.Errorf("got nil authentication, nothing to do")
	}

	secret := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:       obc.Name,
			Namespace:  obc.Namespace,
			Finalizers: []string{finalizer},
		},
	}

	secret.StringData = auth.ToMap()
	return secret, nil
}

func createObjectBucket(ob *v1alpha1.ObjectBucket, c versioned.Interface, retryInterval, retryTimeout time.Duration) (*v1alpha1.ObjectBucket, error) {
	logD.Info("creating ObjectBucket", "name", ob.Name)

	err := wait.PollImmediate(retryInterval, retryTimeout, func() (done bool, err error) {
		ob, err = c.ObjectbucketV1alpha1().ObjectBuckets().Create(ob)
		if err != nil {
			if errors.IsAlreadyExists(err) {
				// The object already exists don't spam the logs, instead let the request be requeued
				return true, err
			}
			// The error could be intermittent, log and try again
			log.Error(err, "probably not fatal, retrying")
			return false, nil
		}
		return true, nil
	})
	return ob, err
}

func createSecret(obc *v1alpha1.ObjectBucketClaim, auth *v1alpha1.Authentication, c kubernetes.Interface, retryInterval, retryTimeout time.Duration) (*corev1.Secret, error) {
	secret, err := newCredentialsSecret(obc, auth)
	if err != nil {
		return nil, err
	}

	err = wait.PollImmediate(retryInterval, retryTimeout, func() (done bool, err error) {
		secret, err = c.CoreV1().Secrets(obc.Namespace).Create(secret)
		if err != nil {
			if errors.IsAlreadyExists(err) {
				// The object already exists don't spam the logs, instead let the request be requeued
				return true, err
			}
			// The error could be intermittent, log and try again
			log.Error(err, "probably not fatal, retrying")
			return false, nil
		}
		return true, nil
	})
	return secret, err
}

func createConfigMap(obc *v1alpha1.ObjectBucketClaim, ep *v1alpha1.Endpoint, c kubernetes.Interface, retryInterval, retryTimeout time.Duration) (*corev1.ConfigMap, error) {
	configMap, err := newBucketConfigMap(ep, obc)
	if err != nil {
		return nil, err
	}

	err = wait.PollImmediate(retryInterval, retryTimeout, func() (done bool, err error) {
		configMap, err = c.CoreV1().ConfigMaps(obc.Namespace).Create(configMap)
		if err != nil {
			if errors.IsAlreadyExists(err) {
				// The object already exists don't spam the logs, instead let the request be requeued
				return true, err
			}
			// The error could be intermittent, log and try again
			log.Error(err, "probably not fatal, retrying")
			return false, nil
		}
		return true, nil
	})
	return configMap, err
}

func deleteConfigMap(cm *corev1.ConfigMap, c kubernetes.Interface) error {
	if cm == nil {
		log.Info("got nil configMap pointer, skipping delete")
		return nil
	}
	removeFinalizer(cm)
	cm, err := c.CoreV1().ConfigMaps(cm.Namespace).Update(cm)
	if err != nil {
		return err
	}

	logD.Info("deleting configMap", "name", cm.Namespace+"/"+cm.Name)
	err = c.CoreV1().ConfigMaps(cm.Namespace).Delete(cm.Name, &metav1.DeleteOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			log.Error(err, "configMap vanished before we could delete it, skipping")
			return nil
		}
		return fmt.Errorf("error deleting configMap %s/%s: %v", cm.Namespace, cm.Name, err)
	}
	return nil
}

func deleteSecret(sec *corev1.Secret, c kubernetes.Interface) error {
	if sec == nil {
		log.Info("got nil secret, skipping")
		return nil
	}

	removeFinalizer(sec)
	sec, err := c.CoreV1().Secrets(sec.Namespace).Update(sec)
	if err != nil {
		return err
	}

	logD.Info("deleting secret", "name", sec.Namespace+"/"+sec.Name)
	err = c.CoreV1().Secrets(sec.Namespace).Delete(sec.Name, &metav1.DeleteOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			log.Error(err, "secret vanished before we could delete it, skipping")
			return nil
		}
		return fmt.Errorf("error deleting Secret %s/%s: %v", sec.Namespace, sec.Name, err)
	}
	return nil
}

func deleteObjectBucket(ob *v1alpha1.ObjectBucket, c versioned.Interface) error {
	if ob == nil {
		log.Error(fmt.Errorf("got nil objectBucket, skipping"), "")
		return nil
	}
	logD.Info("deleting ObjectBucket", "name", ob.Name)
	removeFinalizer(ob)
	ob, err := c.ObjectbucketV1alpha1().ObjectBuckets().Update(ob)
	if err != nil {
		return err
	}

	err = c.ObjectbucketV1alpha1().ObjectBuckets().Delete(ob.Name, &metav1.DeleteOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			log.Error(err, "ObjectBucket vanished before we could delete it, skipping")
			return nil
		}
		return fmt.Errorf("error deleting ObjectBucket %s/%s: %v", ob.Namespace, ob.Name, err)
	}
	return nil
}

func updateClaim(c versioned.Interface, obc *v1alpha1.ObjectBucketClaim, retryInterval, retryTimeout time.Duration) (*v1alpha1.ObjectBucketClaim, error) {
	err := wait.PollImmediate(retryInterval, retryTimeout, func() (done bool, err error) {
		obc, err = c.ObjectbucketV1alpha1().ObjectBucketClaims(obc.Namespace).Update(obc)
		if err != nil {
			return false, err
		}
		return true, nil
	})
	if err != nil {
		return nil, fmt.Errorf("error updating phase: %v", err)
	}
	return obc, nil
}

func updateObjectBucketClaimPhase(c versioned.Interface, obc *v1alpha1.ObjectBucketClaim, phase v1alpha1.ObjectBucketClaimStatusPhase, retryInterval, retryTimeout time.Duration) (*v1alpha1.ObjectBucketClaim, error) {
	obc.Status.Phase = phase
	obc, err := updateClaim(c, obc, retryInterval, retryTimeout)
	if err != nil {
		return nil, err
	}
	return obc, nil
}

func updateObjectBucketPhase(c versioned.Interface, ob *v1alpha1.ObjectBucket, phase v1alpha1.ObjectBucketStatusPhase, retryInterval, retryTimeout time.Duration) (*v1alpha1.ObjectBucket, error) {
	ob.Status.Phase = phase
	err := wait.PollImmediate(retryInterval, retryTimeout, func() (done bool, err error) {
		ob, err = c.ObjectbucketV1alpha1().ObjectBuckets().Update(ob)
		if err != nil {
			return false, err
		}
		return true, nil
	})
	if err != nil {
		return nil, fmt.Errorf("error updating phase: %v", err)
	}
	return ob, nil
}
